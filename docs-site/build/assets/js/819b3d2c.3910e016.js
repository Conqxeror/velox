"use strict";(self.webpackChunkveloxx_docs=self.webpackChunkveloxx_docs||[]).push([[671],{3097:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>c,contentTitle:()=>t,default:()=>x,frontMatter:()=>l,metadata:()=>a,toc:()=>d});const a=JSON.parse('{"id":"api/rust","title":"Rust API Reference","description":"Complete API reference for the Veloxx Rust library.","source":"@site/docs/api/rust.md","sourceDirName":"api","slug":"/api/rust","permalink":"/veloxx/docs/api/rust","draft":false,"unlisted":false,"editUrl":"https://github.com/Conqxeror/veloxx/tree/main/docs-site/docs/api/rust.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Quick Start Guide","permalink":"/veloxx/docs/getting-started/quick-start"},"next":{"title":"Python API Reference","permalink":"/veloxx/docs/api/python"}}');var r=n(4848),i=n(8453);const l={},t="Rust API Reference",c={},d=[{value:"Core Modules",id:"core-modules",level:2},{value:"<code>veloxx::dataframe</code>",id:"veloxxdataframe",level:3},{value:"<code>DataFrame</code>",id:"dataframe",level:4},{value:"Constructors",id:"constructors",level:5},{value:"Core Methods",id:"core-methods",level:5},{value:"Data Manipulation",id:"data-manipulation",level:5},{value:"Aggregation and Grouping",id:"aggregation-and-grouping",level:5},{value:"Joining",id:"joining",level:5},{value:"Sorting and Ordering",id:"sorting-and-ordering",level:5},{value:"Data Cleaning",id:"data-cleaning",level:5},{value:"I/O Operations",id:"io-operations",level:5},{value:"<code>veloxx::series</code>",id:"veloxxseries",level:3},{value:"<code>Series</code>",id:"series",level:4},{value:"Constructors",id:"constructors-1",level:5},{value:"Core Methods",id:"core-methods-1",level:5},{value:"Statistical Methods",id:"statistical-methods",level:5},{value:"<code>veloxx::conditions</code>",id:"veloxxconditions",level:3},{value:"<code>Condition</code>",id:"condition",level:4},{value:"Comparison Conditions",id:"comparison-conditions",level:5},{value:"Logical Conditions",id:"logical-conditions",level:5},{value:"<code>veloxx::expressions</code>",id:"veloxxexpressions",level:3},{value:"<code>Expr</code>",id:"expr",level:4},{value:"Basic Expressions",id:"basic-expressions",level:5},{value:"Arithmetic Expressions",id:"arithmetic-expressions",level:5},{value:"<code>veloxx::types</code>",id:"veloxxtypes",level:3},{value:"<code>DataType</code>",id:"datatype",level:4},{value:"<code>Value</code>",id:"value",level:4},{value:"<code>veloxx::error</code>",id:"veloxxerror",level:3},{value:"<code>VeloxxError</code>",id:"veloxxerror-1",level:4},{value:"Usage Patterns",id:"usage-patterns",level:2},{value:"Basic DataFrame Operations",id:"basic-dataframe-operations",level:3},{value:"Advanced Analytics",id:"advanced-analytics",level:3},{value:"Performance Tips",id:"performance-tips",level:2},{value:"Error Handling",id:"error-handling",level:2}];function o(e){const s={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",h5:"h5",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(s.header,{children:(0,r.jsx)(s.h1,{id:"rust-api-reference",children:"Rust API Reference"})}),"\n",(0,r.jsx)(s.p,{children:"Complete API reference for the Veloxx Rust library."}),"\n",(0,r.jsx)(s.h2,{id:"core-modules",children:"Core Modules"}),"\n",(0,r.jsx)(s.h3,{id:"veloxxdataframe",children:(0,r.jsx)(s.code,{children:"veloxx::dataframe"})}),"\n",(0,r.jsxs)(s.p,{children:["The ",(0,r.jsx)(s.code,{children:"DataFrame"})," is the primary data structure for working with tabular data."]}),"\n",(0,r.jsx)(s.h4,{id:"dataframe",children:(0,r.jsx)(s.code,{children:"DataFrame"})}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-rust",children:"pub struct DataFrame {\n    // Internal implementation\n}\n"})}),"\n",(0,r.jsx)(s.h5,{id:"constructors",children:"Constructors"}),"\n",(0,r.jsxs)("div",{className:"api-section",children:[(0,r.jsx)("div",{className:"api-method",children:"DataFrame::new(columns: BTreeMap<String, Series>) -> Result<DataFrame, VeloxxError>"}),(0,r.jsx)(s.p,{children:"Creates a new DataFrame from a map of column names to Series."}),(0,r.jsxs)("div",{className:"api-parameters",children:[(0,r.jsx)(s.p,{children:(0,r.jsx)(s.strong,{children:"Parameters:"})}),(0,r.jsx)("div",{className:"api-parameter",children:(0,r.jsxs)(s.p,{children:[(0,r.jsx)("span",{className:"parameter-name",children:"columns"}),": ",(0,r.jsx)("span",{className:"parameter-type",children:"BTreeMap<String, Series>"})," - Map of column names to Series objects"]})})]}),(0,r.jsx)(s.p,{children:(0,r.jsx)(s.strong,{children:"Example:"})}),(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-rust",children:'use std::collections::BTreeMap;\nuse veloxx::{DataFrame, Series};\n\nlet mut columns = BTreeMap::new();\ncolumns.insert("name".to_string(), Series::new_string("name", vec![\n    Some("Alice".to_string()), \n    Some("Bob".to_string())\n]));\ncolumns.insert("age".to_string(), Series::new_i32("age", vec![Some(30), Some(25)]));\n\nlet df = DataFrame::new(columns)?;\n'})})]}),"\n",(0,r.jsxs)("div",{className:"api-section",children:[(0,r.jsx)("div",{className:"api-method",children:"DataFrame::from_csv(path: &str) -> Result<DataFrame, VeloxxError>"}),(0,r.jsx)(s.p,{children:"Loads a DataFrame from a CSV file with automatic type inference."}),(0,r.jsxs)("div",{className:"api-parameters",children:[(0,r.jsx)(s.p,{children:(0,r.jsx)(s.strong,{children:"Parameters:"})}),(0,r.jsx)("div",{className:"api-parameter",children:(0,r.jsxs)(s.p,{children:[(0,r.jsx)("span",{className:"parameter-name",children:"path"}),": ",(0,r.jsx)("span",{className:"parameter-type",children:"&str"})," - Path to the CSV file"]})})]}),(0,r.jsx)(s.p,{children:(0,r.jsx)(s.strong,{children:"Example:"})}),(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-rust",children:'let df = DataFrame::from_csv("data/sales.csv")?;\nprintln!("Loaded {} rows", df.row_count());\n'})})]}),"\n",(0,r.jsxs)("div",{className:"api-section",children:[(0,r.jsx)("div",{className:"api-method",children:"DataFrame::from_json(path: &str) -> Result<DataFrame, VeloxxError>"}),(0,r.jsx)(s.p,{children:"Loads a DataFrame from a JSON file."}),(0,r.jsxs)("div",{className:"api-parameters",children:[(0,r.jsx)(s.p,{children:(0,r.jsx)(s.strong,{children:"Parameters:"})}),(0,r.jsx)("div",{className:"api-parameter",children:(0,r.jsxs)(s.p,{children:[(0,r.jsx)("span",{className:"parameter-name",children:"path"}),": ",(0,r.jsx)("span",{className:"parameter-type",children:"&str"})," - Path to the JSON file"]})})]}),(0,r.jsx)(s.p,{children:(0,r.jsx)(s.strong,{children:"Example:"})}),(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-rust",children:'let df = DataFrame::from_json("data/users.json")?;\n'})})]}),"\n",(0,r.jsxs)("div",{className:"api-section",children:[(0,r.jsx)("div",{className:"api-method",children:"DataFrame::from_vec_of_vec(data: Vec<Vec<String>>, column_names: Vec<String>) -> Result<DataFrame, VeloxxError>"}),(0,r.jsx)(s.p,{children:"Creates a DataFrame from a vector of vectors with automatic type inference."}),(0,r.jsxs)("div",{className:"api-parameters",children:[(0,r.jsx)(s.p,{children:(0,r.jsx)(s.strong,{children:"Parameters:"})}),(0,r.jsx)("div",{className:"api-parameter",children:(0,r.jsxs)(s.p,{children:[(0,r.jsx)("span",{className:"parameter-name",children:"data"}),": ",(0,r.jsx)("span",{className:"parameter-type",children:"Vec<Vec<String>>"})," - 2D vector containing the data"]})}),(0,r.jsx)("div",{className:"api-parameter",children:(0,r.jsxs)(s.p,{children:[(0,r.jsx)("span",{className:"parameter-name",children:"column_names"}),": ",(0,r.jsx)("span",{className:"parameter-type",children:"Vec<String>"})," - Names for the columns"]})})]}),(0,r.jsx)(s.p,{children:(0,r.jsx)(s.strong,{children:"Example:"})}),(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-rust",children:'let data = vec![\n    vec!["Alice".to_string(), "30".to_string(), "Engineer".to_string()],\n    vec!["Bob".to_string(), "25".to_string(), "Designer".to_string()],\n];\nlet columns = vec!["name".to_string(), "age".to_string(), "role".to_string()];\nlet df = DataFrame::from_vec_of_vec(data, columns)?;\n'})})]}),"\n",(0,r.jsx)(s.h5,{id:"core-methods",children:"Core Methods"}),"\n",(0,r.jsxs)("div",{className:"api-section",children:[(0,r.jsx)("div",{className:"api-method",children:"fn row_count(&self) -> usize"}),(0,r.jsx)(s.p,{children:"Returns the number of rows in the DataFrame."}),(0,r.jsx)(s.p,{children:(0,r.jsx)(s.strong,{children:"Example:"})}),(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-rust",children:'println!("DataFrame has {} rows", df.row_count());\n'})})]}),"\n",(0,r.jsxs)("div",{className:"api-section",children:[(0,r.jsx)("div",{className:"api-method",children:"fn column_count(&self) -> usize"}),(0,r.jsx)(s.p,{children:"Returns the number of columns in the DataFrame."}),(0,r.jsx)(s.p,{children:(0,r.jsx)(s.strong,{children:"Example:"})}),(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-rust",children:'println!("DataFrame has {} columns", df.column_count());\n'})})]}),"\n",(0,r.jsxs)("div",{className:"api-section",children:[(0,r.jsx)("div",{className:"api-method",children:"fn column_names(&self) -> Vec<&String>"}),(0,r.jsx)(s.p,{children:"Returns a vector of column names."}),(0,r.jsx)(s.p,{children:(0,r.jsx)(s.strong,{children:"Example:"})}),(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-rust",children:'let names = df.column_names();\nfor name in names {\n    println!("Column: {}", name);\n}\n'})})]}),"\n",(0,r.jsxs)("div",{className:"api-section",children:[(0,r.jsx)("div",{className:"api-method",children:"fn get_column(&self, name: &str) -> Option<&Series>"}),(0,r.jsx)(s.p,{children:"Gets a reference to a column by name."}),(0,r.jsxs)("div",{className:"api-parameters",children:[(0,r.jsx)(s.p,{children:(0,r.jsx)(s.strong,{children:"Parameters:"})}),(0,r.jsx)("div",{className:"api-parameter",children:(0,r.jsxs)(s.p,{children:[(0,r.jsx)("span",{className:"parameter-name",children:"name"}),": ",(0,r.jsx)("span",{className:"parameter-type",children:"&str"})," - Name of the column to retrieve"]})})]}),(0,r.jsx)(s.p,{children:(0,r.jsx)(s.strong,{children:"Example:"})}),(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-rust",children:'if let Some(age_column) = df.get_column("age") {\n    println!("Age column has {} values", age_column.len());\n}\n'})})]}),"\n",(0,r.jsx)(s.h5,{id:"data-manipulation",children:"Data Manipulation"}),"\n",(0,r.jsxs)("div",{className:"api-section",children:[(0,r.jsx)("div",{className:"api-method",children:"fn filter(&self, condition: &Condition) -> Result<DataFrame, VeloxxError>"}),(0,r.jsx)(s.p,{children:"Filters rows based on a condition."}),(0,r.jsxs)("div",{className:"api-parameters",children:[(0,r.jsx)(s.p,{children:(0,r.jsx)(s.strong,{children:"Parameters:"})}),(0,r.jsx)("div",{className:"api-parameter",children:(0,r.jsxs)(s.p,{children:[(0,r.jsx)("span",{className:"parameter-name",children:"condition"}),": ",(0,r.jsx)("span",{className:"parameter-type",children:"&Condition"})," - The filtering condition"]})})]}),(0,r.jsx)(s.p,{children:(0,r.jsx)(s.strong,{children:"Example:"})}),(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-rust",children:'use veloxx::{Condition, Value};\n\nlet condition = Condition::Gt("age".to_string(), Value::I32(25));\nlet filtered_df = df.filter(&condition)?;\n'})})]}),"\n",(0,r.jsxs)("div",{className:"api-section",children:[(0,r.jsx)("div",{className:"api-method",children:"fn select_columns(&self, names: Vec<String>) -> Result<DataFrame, VeloxxError>"}),(0,r.jsx)(s.p,{children:"Selects specific columns from the DataFrame."}),(0,r.jsxs)("div",{className:"api-parameters",children:[(0,r.jsx)(s.p,{children:(0,r.jsx)(s.strong,{children:"Parameters:"})}),(0,r.jsx)("div",{className:"api-parameter",children:(0,r.jsxs)(s.p,{children:[(0,r.jsx)("span",{className:"parameter-name",children:"names"}),": ",(0,r.jsx)("span",{className:"parameter-type",children:"Vec<String>"})," - Names of columns to select"]})})]}),(0,r.jsx)(s.p,{children:(0,r.jsx)(s.strong,{children:"Example:"})}),(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-rust",children:'let selected = df.select_columns(vec!["name".to_string(), "age".to_string()])?;\n'})})]}),"\n",(0,r.jsxs)("div",{className:"api-section",children:[(0,r.jsx)("div",{className:"api-method",children:"fn drop_columns(&self, names: Vec<String>) -> Result<DataFrame, VeloxxError>"}),(0,r.jsx)(s.p,{children:"Removes specified columns from the DataFrame."}),(0,r.jsxs)("div",{className:"api-parameters",children:[(0,r.jsx)(s.p,{children:(0,r.jsx)(s.strong,{children:"Parameters:"})}),(0,r.jsx)("div",{className:"api-parameter",children:(0,r.jsxs)(s.p,{children:[(0,r.jsx)("span",{className:"parameter-name",children:"names"}),": ",(0,r.jsx)("span",{className:"parameter-type",children:"Vec<String>"})," - Names of columns to drop"]})})]}),(0,r.jsx)(s.p,{children:(0,r.jsx)(s.strong,{children:"Example:"})}),(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-rust",children:'let without_id = df.drop_columns(vec!["id".to_string()])?;\n'})})]}),"\n",(0,r.jsxs)("div",{className:"api-section",children:[(0,r.jsx)("div",{className:"api-method",children:"fn rename_column(&self, old_name: &str, new_name: &str) -> Result<DataFrame, VeloxxError>"}),(0,r.jsx)(s.p,{children:"Renames a column in the DataFrame."}),(0,r.jsxs)("div",{className:"api-parameters",children:[(0,r.jsx)(s.p,{children:(0,r.jsx)(s.strong,{children:"Parameters:"})}),(0,r.jsx)("div",{className:"api-parameter",children:(0,r.jsxs)(s.p,{children:[(0,r.jsx)("span",{className:"parameter-name",children:"old_name"}),": ",(0,r.jsx)("span",{className:"parameter-type",children:"&str"})," - Current name of the column"]})}),(0,r.jsx)("div",{className:"api-parameter",children:(0,r.jsxs)(s.p,{children:[(0,r.jsx)("span",{className:"parameter-name",children:"new_name"}),": ",(0,r.jsx)("span",{className:"parameter-type",children:"&str"})," - New name for the column"]})})]}),(0,r.jsx)(s.p,{children:(0,r.jsx)(s.strong,{children:"Example:"})}),(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-rust",children:'let renamed = df.rename_column("age", "years")?;\n'})})]}),"\n",(0,r.jsxs)("div",{className:"api-section",children:[(0,r.jsx)("div",{className:"api-method",children:"fn with_column(&self, name: &str, expr: &Expr) -> Result<DataFrame, VeloxxError>"}),(0,r.jsx)(s.p,{children:"Adds a new column or replaces an existing one using an expression."}),(0,r.jsxs)("div",{className:"api-parameters",children:[(0,r.jsx)(s.p,{children:(0,r.jsx)(s.strong,{children:"Parameters:"})}),(0,r.jsx)("div",{className:"api-parameter",children:(0,r.jsxs)(s.p,{children:[(0,r.jsx)("span",{className:"parameter-name",children:"name"}),": ",(0,r.jsx)("span",{className:"parameter-type",children:"&str"})," - Name of the new column"]})}),(0,r.jsx)("div",{className:"api-parameter",children:(0,r.jsxs)(s.p,{children:[(0,r.jsx)("span",{className:"parameter-name",children:"expr"}),": ",(0,r.jsx)("span",{className:"parameter-type",children:"&Expr"})," - Expression to compute the column values"]})})]}),(0,r.jsx)(s.p,{children:(0,r.jsx)(s.strong,{children:"Example:"})}),(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-rust",children:'use veloxx::Expr;\n\nlet expr = Expr::Add(\n    Box::new(Expr::Column("salary".to_string())),\n    Box::new(Expr::Literal(Value::F64(1000.0)))\n);\nlet with_bonus = df.with_column("salary_with_bonus", &expr)?;\n'})})]}),"\n",(0,r.jsx)(s.h5,{id:"aggregation-and-grouping",children:"Aggregation and Grouping"}),"\n",(0,r.jsxs)("div",{className:"api-section",children:[(0,r.jsx)("div",{className:"api-method",children:"fn group_by(&self, by_columns: Vec<String>) -> Result<GroupedDataFrame, VeloxxError>"}),(0,r.jsx)(s.p,{children:"Groups the DataFrame by specified columns."}),(0,r.jsxs)("div",{className:"api-parameters",children:[(0,r.jsx)(s.p,{children:(0,r.jsx)(s.strong,{children:"Parameters:"})}),(0,r.jsx)("div",{className:"api-parameter",children:(0,r.jsxs)(s.p,{children:[(0,r.jsx)("span",{className:"parameter-name",children:"by_columns"}),": ",(0,r.jsx)("span",{className:"parameter-type",children:"Vec<String>"})," - Columns to group by"]})})]}),(0,r.jsx)(s.p,{children:(0,r.jsx)(s.strong,{children:"Example:"})}),(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-rust",children:'let grouped = df.group_by(vec!["department".to_string()])?;\nlet result = grouped.agg(vec![("salary", "mean"), ("age", "count")])?;\n'})})]}),"\n",(0,r.jsxs)("div",{className:"api-section",children:[(0,r.jsx)("div",{className:"api-method",children:"fn describe(&self) -> Result<DataFrame, VeloxxError>"}),(0,r.jsx)(s.p,{children:"Generates descriptive statistics for numeric columns."}),(0,r.jsx)(s.p,{children:(0,r.jsx)(s.strong,{children:"Example:"})}),(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-rust",children:'let stats = df.describe()?;\nprintln!("{}", stats);\n'})})]}),"\n",(0,r.jsx)(s.h5,{id:"joining",children:"Joining"}),"\n",(0,r.jsxs)("div",{className:"api-section",children:[(0,r.jsx)("div",{className:"api-method",children:"fn join(&self, other: &DataFrame, on_column: &str, join_type: JoinType) -> Result<DataFrame, VeloxxError>"}),(0,r.jsx)(s.p,{children:"Joins this DataFrame with another DataFrame."}),(0,r.jsxs)("div",{className:"api-parameters",children:[(0,r.jsx)(s.p,{children:(0,r.jsx)(s.strong,{children:"Parameters:"})}),(0,r.jsx)("div",{className:"api-parameter",children:(0,r.jsxs)(s.p,{children:[(0,r.jsx)("span",{className:"parameter-name",children:"other"}),": ",(0,r.jsx)("span",{className:"parameter-type",children:"&DataFrame"})," - DataFrame to join with"]})}),(0,r.jsx)("div",{className:"api-parameter",children:(0,r.jsxs)(s.p,{children:[(0,r.jsx)("span",{className:"parameter-name",children:"on_column"}),": ",(0,r.jsx)("span",{className:"parameter-type",children:"&str"})," - Column name to join on"]})}),(0,r.jsx)("div",{className:"api-parameter",children:(0,r.jsxs)(s.p,{children:[(0,r.jsx)("span",{className:"parameter-name",children:"join_type"}),": ",(0,r.jsx)("span",{className:"parameter-type",children:"JoinType"})," - Type of join (Inner, Left, Right)"]})})]}),(0,r.jsx)(s.p,{children:(0,r.jsx)(s.strong,{children:"Example:"})}),(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-rust",children:'use veloxx::JoinType;\n\nlet joined = df1.join(&df2, "user_id", JoinType::Inner)?;\n'})})]}),"\n",(0,r.jsx)(s.h5,{id:"sorting-and-ordering",children:"Sorting and Ordering"}),"\n",(0,r.jsxs)("div",{className:"api-section",children:[(0,r.jsx)("div",{className:"api-method",children:"fn sort(&self, by_columns: Vec<String>, ascending: bool) -> Result<DataFrame, VeloxxError>"}),(0,r.jsx)(s.p,{children:"Sorts the DataFrame by specified columns."}),(0,r.jsxs)("div",{className:"api-parameters",children:[(0,r.jsx)(s.p,{children:(0,r.jsx)(s.strong,{children:"Parameters:"})}),(0,r.jsx)("div",{className:"api-parameter",children:(0,r.jsxs)(s.p,{children:[(0,r.jsx)("span",{className:"parameter-name",children:"by_columns"}),": ",(0,r.jsx)("span",{className:"parameter-type",children:"Vec<String>"})," - Columns to sort by"]})}),(0,r.jsx)("div",{className:"api-parameter",children:(0,r.jsxs)(s.p,{children:[(0,r.jsx)("span",{className:"parameter-name",children:"ascending"}),": ",(0,r.jsx)("span",{className:"parameter-type",children:"bool"})," - Sort order (true for ascending, false for descending)"]})})]}),(0,r.jsx)(s.p,{children:(0,r.jsx)(s.strong,{children:"Example:"})}),(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-rust",children:'let sorted = df.sort(vec!["age".to_string(), "name".to_string()], true)?;\n'})})]}),"\n",(0,r.jsx)(s.h5,{id:"data-cleaning",children:"Data Cleaning"}),"\n",(0,r.jsxs)("div",{className:"api-section",children:[(0,r.jsx)("div",{className:"api-method",children:"fn drop_nulls(&self) -> Result<DataFrame, VeloxxError>"}),(0,r.jsx)(s.p,{children:"Removes rows containing any null values."}),(0,r.jsx)(s.p,{children:(0,r.jsx)(s.strong,{children:"Example:"})}),(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-rust",children:"let clean_df = df.drop_nulls()?;\n"})})]}),"\n",(0,r.jsxs)("div",{className:"api-section",children:[(0,r.jsx)("div",{className:"api-method",children:"fn fill_nulls(&self, value: Value) -> Result<DataFrame, VeloxxError>"}),(0,r.jsx)(s.p,{children:"Fills null values with a specified value."}),(0,r.jsxs)("div",{className:"api-parameters",children:[(0,r.jsx)(s.p,{children:(0,r.jsx)(s.strong,{children:"Parameters:"})}),(0,r.jsx)("div",{className:"api-parameter",children:(0,r.jsxs)(s.p,{children:[(0,r.jsx)("span",{className:"parameter-name",children:"value"}),": ",(0,r.jsx)("span",{className:"parameter-type",children:"Value"})," - Value to use for filling nulls"]})})]}),(0,r.jsx)(s.p,{children:(0,r.jsx)(s.strong,{children:"Example:"})}),(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-rust",children:"let filled = df.fill_nulls(Value::I32(0))?;\n"})})]}),"\n",(0,r.jsx)(s.h5,{id:"io-operations",children:"I/O Operations"}),"\n",(0,r.jsxs)("div",{className:"api-section",children:[(0,r.jsx)("div",{className:"api-method",children:"fn to_csv(&self, path: &str) -> Result<(), VeloxxError>"}),(0,r.jsx)(s.p,{children:"Writes the DataFrame to a CSV file."}),(0,r.jsxs)("div",{className:"api-parameters",children:[(0,r.jsx)(s.p,{children:(0,r.jsx)(s.strong,{children:"Parameters:"})}),(0,r.jsx)("div",{className:"api-parameter",children:(0,r.jsxs)(s.p,{children:[(0,r.jsx)("span",{className:"parameter-name",children:"path"}),": ",(0,r.jsx)("span",{className:"parameter-type",children:"&str"})," - Output file path"]})})]}),(0,r.jsx)(s.p,{children:(0,r.jsx)(s.strong,{children:"Example:"})}),(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-rust",children:'df.to_csv("output/results.csv")?;\n'})})]}),"\n",(0,r.jsx)(s.h3,{id:"veloxxseries",children:(0,r.jsx)(s.code,{children:"veloxx::series"})}),"\n",(0,r.jsxs)(s.p,{children:["The ",(0,r.jsx)(s.code,{children:"Series"})," represents a single column of data with a specific type."]}),"\n",(0,r.jsx)(s.h4,{id:"series",children:(0,r.jsx)(s.code,{children:"Series"})}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-rust",children:"pub enum Series {\n    I32(String, Vec<Option<i32>>),\n    F64(String, Vec<Option<f64>>),\n    Bool(String, Vec<Option<bool>>),\n    String(String, Vec<Option<String>>),\n    DateTime(String, Vec<Option<i64>>),\n}\n"})}),"\n",(0,r.jsx)(s.h5,{id:"constructors-1",children:"Constructors"}),"\n",(0,r.jsxs)("div",{className:"api-section",children:[(0,r.jsx)("div",{className:"api-method",children:"Series::new_i32(name: &str, data: Vec<Option<i32>>) -> Series"}),(0,r.jsx)(s.p,{children:"Creates a new integer Series."}),(0,r.jsx)(s.p,{children:(0,r.jsx)(s.strong,{children:"Example:"})}),(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-rust",children:'let ages = Series::new_i32("age", vec![Some(25), Some(30), None, Some(35)]);\n'})})]}),"\n",(0,r.jsxs)("div",{className:"api-section",children:[(0,r.jsx)("div",{className:"api-method",children:"Series::new_f64(name: &str, data: Vec<Option<f64>>) -> Series"}),(0,r.jsx)(s.p,{children:"Creates a new floating-point Series."}),(0,r.jsx)(s.p,{children:(0,r.jsx)(s.strong,{children:"Example:"})}),(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-rust",children:'let salaries = Series::new_f64("salary", vec![Some(50000.0), Some(75000.0), Some(60000.0)]);\n'})})]}),"\n",(0,r.jsxs)("div",{className:"api-section",children:[(0,r.jsx)("div",{className:"api-method",children:"Series::new_string(name: &str, data: Vec<Option<String>>) -> Series"}),(0,r.jsx)(s.p,{children:"Creates a new string Series."}),(0,r.jsx)(s.p,{children:(0,r.jsx)(s.strong,{children:"Example:"})}),(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-rust",children:'let names = Series::new_string("name", vec![\n    Some("Alice".to_string()), \n    Some("Bob".to_string()),\n    None\n]);\n'})})]}),"\n",(0,r.jsxs)("div",{className:"api-section",children:[(0,r.jsx)("div",{className:"api-method",children:"Series::new_bool(name: &str, data: Vec<Option<bool>>) -> Series"}),(0,r.jsx)(s.p,{children:"Creates a new boolean Series."}),(0,r.jsx)(s.p,{children:(0,r.jsx)(s.strong,{children:"Example:"})}),(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-rust",children:'let active = Series::new_bool("is_active", vec![Some(true), Some(false), Some(true)]);\n'})})]}),"\n",(0,r.jsxs)("div",{className:"api-section",children:[(0,r.jsx)("div",{className:"api-method",children:"Series::new_datetime(name: &str, data: Vec<Option<i64>>) -> Series"}),(0,r.jsx)(s.p,{children:"Creates a new datetime Series (timestamps as i64)."}),(0,r.jsx)(s.p,{children:(0,r.jsx)(s.strong,{children:"Example:"})}),(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-rust",children:'let timestamps = Series::new_datetime("created_at", vec![\n    Some(1678886400), \n    Some(1678972800), \n    None\n]);\n'})})]}),"\n",(0,r.jsx)(s.h5,{id:"core-methods-1",children:"Core Methods"}),"\n",(0,r.jsxs)("div",{className:"api-section",children:[(0,r.jsx)("div",{className:"api-method",children:"fn name(&self) -> &str"}),(0,r.jsx)(s.p,{children:"Returns the name of the Series."}),(0,r.jsx)(s.p,{children:(0,r.jsx)(s.strong,{children:"Example:"})}),(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-rust",children:'println!("Series name: {}", series.name());\n'})})]}),"\n",(0,r.jsxs)("div",{className:"api-section",children:[(0,r.jsx)("div",{className:"api-method",children:"fn len(&self) -> usize"}),(0,r.jsx)(s.p,{children:"Returns the length of the Series."}),(0,r.jsx)(s.p,{children:(0,r.jsx)(s.strong,{children:"Example:"})}),(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-rust",children:'println!("Series has {} values", series.len());\n'})})]}),"\n",(0,r.jsxs)("div",{className:"api-section",children:[(0,r.jsx)("div",{className:"api-method",children:"fn is_empty(&self) -> bool"}),(0,r.jsx)(s.p,{children:"Checks if the Series is empty."}),(0,r.jsx)(s.p,{children:(0,r.jsx)(s.strong,{children:"Example:"})}),(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-rust",children:'if series.is_empty() {\n    println!("Series is empty");\n}\n'})})]}),"\n",(0,r.jsxs)("div",{className:"api-section",children:[(0,r.jsx)("div",{className:"api-method",children:"fn data_type(&self) -> DataType"}),(0,r.jsx)(s.p,{children:"Returns the data type of the Series."}),(0,r.jsx)(s.p,{children:(0,r.jsx)(s.strong,{children:"Example:"})}),(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-rust",children:'match series.data_type() {\n    DataType::I32 => println!("Integer series"),\n    DataType::F64 => println!("Float series"),\n    DataType::String => println!("String series"),\n    _ => println!("Other type"),\n}\n'})})]}),"\n",(0,r.jsxs)("div",{className:"api-section",children:[(0,r.jsx)("div",{className:"api-method",children:"fn get_value(&self, index: usize) -> Option<Value>"}),(0,r.jsx)(s.p,{children:"Gets the value at a specific index."}),(0,r.jsxs)("div",{className:"api-parameters",children:[(0,r.jsx)(s.p,{children:(0,r.jsx)(s.strong,{children:"Parameters:"})}),(0,r.jsx)("div",{className:"api-parameter",children:(0,r.jsxs)(s.p,{children:[(0,r.jsx)("span",{className:"parameter-name",children:"index"}),": ",(0,r.jsx)("span",{className:"parameter-type",children:"usize"})," - Index of the value to retrieve"]})})]}),(0,r.jsx)(s.p,{children:(0,r.jsx)(s.strong,{children:"Example:"})}),(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-rust",children:'if let Some(value) = series.get_value(0) {\n    println!("First value: {:?}", value);\n}\n'})})]}),"\n",(0,r.jsx)(s.h5,{id:"statistical-methods",children:"Statistical Methods"}),"\n",(0,r.jsxs)("div",{className:"api-section",children:[(0,r.jsx)("div",{className:"api-method",children:"fn sum(&self) -> Result<Option<Value>, VeloxxError>"}),(0,r.jsx)(s.p,{children:"Calculates the sum of numeric values."}),(0,r.jsx)(s.p,{children:(0,r.jsx)(s.strong,{children:"Example:"})}),(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-rust",children:'if let Ok(Some(Value::F64(total))) = series.sum() {\n    println!("Sum: {}", total);\n}\n'})})]}),"\n",(0,r.jsxs)("div",{className:"api-section",children:[(0,r.jsx)("div",{className:"api-method",children:"fn mean(&self) -> Result<Option<Value>, VeloxxError>"}),(0,r.jsx)(s.p,{children:"Calculates the mean of numeric values."}),(0,r.jsx)(s.p,{children:(0,r.jsx)(s.strong,{children:"Example:"})}),(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-rust",children:'if let Ok(Some(Value::F64(avg))) = series.mean() {\n    println!("Average: {}", avg);\n}\n'})})]}),"\n",(0,r.jsxs)("div",{className:"api-section",children:[(0,r.jsx)("div",{className:"api-method",children:"fn median(&self) -> Result<Option<Value>, VeloxxError>"}),(0,r.jsx)(s.p,{children:"Calculates the median of numeric values."}),(0,r.jsx)(s.p,{children:(0,r.jsx)(s.strong,{children:"Example:"})}),(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-rust",children:'if let Ok(Some(Value::F64(med))) = series.median() {\n    println!("Median: {}", med);\n}\n'})})]}),"\n",(0,r.jsxs)("div",{className:"api-section",children:[(0,r.jsx)("div",{className:"api-method",children:"fn min(&self) -> Result<Option<Value>, VeloxxError>"}),(0,r.jsx)(s.p,{children:"Finds the minimum value."}),(0,r.jsx)(s.p,{children:(0,r.jsx)(s.strong,{children:"Example:"})}),(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-rust",children:'if let Ok(Some(min_val)) = series.min() {\n    println!("Minimum: {:?}", min_val);\n}\n'})})]}),"\n",(0,r.jsxs)("div",{className:"api-section",children:[(0,r.jsx)("div",{className:"api-method",children:"fn max(&self) -> Result<Option<Value>, VeloxxError>"}),(0,r.jsx)(s.p,{children:"Finds the maximum value."}),(0,r.jsx)(s.p,{children:(0,r.jsx)(s.strong,{children:"Example:"})}),(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-rust",children:'if let Ok(Some(max_val)) = series.max() {\n    println!("Maximum: {:?}", max_val);\n}\n'})})]}),"\n",(0,r.jsxs)("div",{className:"api-section",children:[(0,r.jsx)("div",{className:"api-method",children:"fn std_dev(&self) -> Result<Option<Value>, VeloxxError>"}),(0,r.jsx)(s.p,{children:"Calculates the standard deviation."}),(0,r.jsx)(s.p,{children:(0,r.jsx)(s.strong,{children:"Example:"})}),(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-rust",children:'if let Ok(Some(Value::F64(std))) = series.std_dev() {\n    println!("Standard deviation: {}", std);\n}\n'})})]}),"\n",(0,r.jsxs)("div",{className:"api-section",children:[(0,r.jsx)("div",{className:"api-method",children:"fn count(&self) -> usize"}),(0,r.jsx)(s.p,{children:"Counts non-null values."}),(0,r.jsx)(s.p,{children:(0,r.jsx)(s.strong,{children:"Example:"})}),(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-rust",children:'println!("Non-null values: {}", series.count());\n'})})]}),"\n",(0,r.jsxs)("div",{className:"api-section",children:[(0,r.jsx)("div",{className:"api-method",children:"fn unique(&self) -> Result<Series, VeloxxError>"}),(0,r.jsx)(s.p,{children:"Returns a Series with unique values."}),(0,r.jsx)(s.p,{children:(0,r.jsx)(s.strong,{children:"Example:"})}),(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-rust",children:'let unique_values = series.unique()?;\nprintln!("Unique values: {}", unique_values.len());\n'})})]}),"\n",(0,r.jsx)(s.h3,{id:"veloxxconditions",children:(0,r.jsx)(s.code,{children:"veloxx::conditions"})}),"\n",(0,r.jsx)(s.p,{children:"Conditions are used for filtering DataFrames."}),"\n",(0,r.jsx)(s.h4,{id:"condition",children:(0,r.jsx)(s.code,{children:"Condition"})}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-rust",children:"pub enum Condition {\n    Eq(String, Value),\n    Ne(String, Value),\n    Lt(String, Value),\n    Le(String, Value),\n    Gt(String, Value),\n    Ge(String, Value),\n    And(Box<Condition>, Box<Condition>),\n    Or(Box<Condition>, Box<Condition>),\n    Not(Box<Condition>),\n}\n"})}),"\n",(0,r.jsx)(s.h5,{id:"comparison-conditions",children:"Comparison Conditions"}),"\n",(0,r.jsxs)("div",{className:"api-section",children:[(0,r.jsx)("div",{className:"api-method",children:"Condition::Eq(column: String, value: Value)"}),(0,r.jsx)(s.p,{children:"Equal to condition."}),(0,r.jsx)(s.p,{children:(0,r.jsx)(s.strong,{children:"Example:"})}),(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-rust",children:'let condition = Condition::Eq("status".to_string(), Value::String("active".to_string()));\n'})})]}),"\n",(0,r.jsxs)("div",{className:"api-section",children:[(0,r.jsx)("div",{className:"api-method",children:"Condition::Ne(column: String, value: Value)"}),(0,r.jsx)(s.p,{children:"Not equal to condition."}),(0,r.jsx)(s.p,{children:(0,r.jsx)(s.strong,{children:"Example:"})}),(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-rust",children:'let condition = Condition::Ne("age".to_string(), Value::I32(0));\n'})})]}),"\n",(0,r.jsxs)("div",{className:"api-section",children:[(0,r.jsx)("div",{className:"api-method",children:"Condition::Lt(column: String, value: Value)"}),(0,r.jsx)(s.p,{children:"Less than condition."}),(0,r.jsx)(s.p,{children:(0,r.jsx)(s.strong,{children:"Example:"})}),(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-rust",children:'let condition = Condition::Lt("price".to_string(), Value::F64(100.0));\n'})})]}),"\n",(0,r.jsxs)("div",{className:"api-section",children:[(0,r.jsx)("div",{className:"api-method",children:"Condition::Gt(column: String, value: Value)"}),(0,r.jsx)(s.p,{children:"Greater than condition."}),(0,r.jsx)(s.p,{children:(0,r.jsx)(s.strong,{children:"Example:"})}),(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-rust",children:'let condition = Condition::Gt("score".to_string(), Value::I32(80));\n'})})]}),"\n",(0,r.jsx)(s.h5,{id:"logical-conditions",children:"Logical Conditions"}),"\n",(0,r.jsxs)("div",{className:"api-section",children:[(0,r.jsx)("div",{className:"api-method",children:"Condition::And(left: Box<Condition>, right: Box<Condition>)"}),(0,r.jsx)(s.p,{children:"Logical AND condition."}),(0,r.jsx)(s.p,{children:(0,r.jsx)(s.strong,{children:"Example:"})}),(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-rust",children:'let condition = Condition::And(\n    Box::new(Condition::Gt("age".to_string(), Value::I32(18))),\n    Box::new(Condition::Lt("age".to_string(), Value::I32(65)))\n);\n'})})]}),"\n",(0,r.jsxs)("div",{className:"api-section",children:[(0,r.jsx)("div",{className:"api-method",children:"Condition::Or(left: Box<Condition>, right: Box<Condition>)"}),(0,r.jsx)(s.p,{children:"Logical OR condition."}),(0,r.jsx)(s.p,{children:(0,r.jsx)(s.strong,{children:"Example:"})}),(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-rust",children:'let condition = Condition::Or(\n    Box::new(Condition::Eq("role".to_string(), Value::String("admin".to_string()))),\n    Box::new(Condition::Eq("role".to_string(), Value::String("manager".to_string())))\n);\n'})})]}),"\n",(0,r.jsx)(s.h3,{id:"veloxxexpressions",children:(0,r.jsx)(s.code,{children:"veloxx::expressions"})}),"\n",(0,r.jsx)(s.p,{children:"Expressions are used for creating computed columns."}),"\n",(0,r.jsx)(s.h4,{id:"expr",children:(0,r.jsx)(s.code,{children:"Expr"})}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-rust",children:"pub enum Expr {\n    Column(String),\n    Literal(Value),\n    Add(Box<Expr>, Box<Expr>),\n    Subtract(Box<Expr>, Box<Expr>),\n    Multiply(Box<Expr>, Box<Expr>),\n    Divide(Box<Expr>, Box<Expr>),\n    // ... more expression types\n}\n"})}),"\n",(0,r.jsx)(s.h5,{id:"basic-expressions",children:"Basic Expressions"}),"\n",(0,r.jsxs)("div",{className:"api-section",children:[(0,r.jsx)("div",{className:"api-method",children:"Expr::Column(name: String)"}),(0,r.jsx)(s.p,{children:"References a column by name."}),(0,r.jsx)(s.p,{children:(0,r.jsx)(s.strong,{children:"Example:"})}),(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-rust",children:'let expr = Expr::Column("salary".to_string());\n'})})]}),"\n",(0,r.jsxs)("div",{className:"api-section",children:[(0,r.jsx)("div",{className:"api-method",children:"Expr::Literal(value: Value)"}),(0,r.jsx)(s.p,{children:"A literal value."}),(0,r.jsx)(s.p,{children:(0,r.jsx)(s.strong,{children:"Example:"})}),(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-rust",children:"let expr = Expr::Literal(Value::F64(1000.0));\n"})})]}),"\n",(0,r.jsx)(s.h5,{id:"arithmetic-expressions",children:"Arithmetic Expressions"}),"\n",(0,r.jsxs)("div",{className:"api-section",children:[(0,r.jsx)("div",{className:"api-method",children:"Expr::Add(left: Box<Expr>, right: Box<Expr>)"}),(0,r.jsx)(s.p,{children:"Addition expression."}),(0,r.jsx)(s.p,{children:(0,r.jsx)(s.strong,{children:"Example:"})}),(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-rust",children:'let expr = Expr::Add(\n    Box::new(Expr::Column("base_salary".to_string())),\n    Box::new(Expr::Column("bonus".to_string()))\n);\n'})})]}),"\n",(0,r.jsx)(s.h3,{id:"veloxxtypes",children:(0,r.jsx)(s.code,{children:"veloxx::types"})}),"\n",(0,r.jsx)(s.p,{children:"Core data types and values."}),"\n",(0,r.jsx)(s.h4,{id:"datatype",children:(0,r.jsx)(s.code,{children:"DataType"})}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-rust",children:"pub enum DataType {\n    I32,\n    F64,\n    Bool,\n    String,\n    DateTime,\n}\n"})}),"\n",(0,r.jsx)(s.h4,{id:"value",children:(0,r.jsx)(s.code,{children:"Value"})}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-rust",children:"pub enum Value {\n    I32(i32),\n    F64(f64),\n    Bool(bool),\n    String(String),\n    DateTime(i64),\n    Null,\n}\n"})}),"\n",(0,r.jsx)(s.h3,{id:"veloxxerror",children:(0,r.jsx)(s.code,{children:"veloxx::error"})}),"\n",(0,r.jsx)(s.p,{children:"Error handling for the library."}),"\n",(0,r.jsx)(s.h4,{id:"veloxxerror-1",children:(0,r.jsx)(s.code,{children:"VeloxxError"})}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-rust",children:"pub enum VeloxxError {\n    ColumnNotFound(String),\n    TypeMismatch(String),\n    InvalidOperation(String),\n    IoError(String),\n    ParseError(String),\n}\n"})}),"\n",(0,r.jsx)(s.h2,{id:"usage-patterns",children:"Usage Patterns"}),"\n",(0,r.jsx)(s.h3,{id:"basic-dataframe-operations",children:"Basic DataFrame Operations"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-rust",children:'use veloxx::prelude::*;\nuse std::collections::BTreeMap;\n\nfn main() -> Result<(), VeloxxError> {\n    // Create DataFrame\n    let mut columns = BTreeMap::new();\n    columns.insert("name".to_string(), Series::new_string("name", vec![\n        Some("Alice".to_string()), Some("Bob".to_string())\n    ]));\n    columns.insert("age".to_string(), Series::new_i32("age", vec![Some(30), Some(25)]));\n    \n    let df = DataFrame::new(columns)?;\n    \n    // Filter\n    let filtered = df.filter(&Condition::Gt("age".to_string(), Value::I32(25)))?;\n    \n    // Add computed column\n    let expr = Expr::Add(\n        Box::new(Expr::Column("age".to_string())),\n        Box::new(Expr::Literal(Value::I32(10)))\n    );\n    let with_future_age = df.with_column("age_in_10_years", &expr)?;\n    \n    Ok(())\n}\n'})}),"\n",(0,r.jsx)(s.h3,{id:"advanced-analytics",children:"Advanced Analytics"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-rust",children:'use veloxx::prelude::*;\n\nfn analyze_sales_data() -> Result<(), VeloxxError> {\n    // Load data\n    let df = DataFrame::from_csv("sales_data.csv")?;\n    \n    // Complex filtering\n    let condition = Condition::And(\n        Box::new(Condition::Gt("amount".to_string(), Value::F64(1000.0))),\n        Box::new(Condition::Eq("status".to_string(), Value::String("completed".to_string())))\n    );\n    let high_value_sales = df.filter(&condition)?;\n    \n    // Group by and aggregate\n    let summary = high_value_sales\n        .group_by(vec!["region".to_string(), "product_category".to_string()])?\n        .agg(vec![\n            ("amount", "sum"),\n            ("amount", "mean"),\n            ("customer_id", "count")\n        ])?;\n    \n    // Export results\n    summary.to_csv("sales_summary.csv")?;\n    \n    Ok(())\n}\n'})}),"\n",(0,r.jsx)(s.h2,{id:"performance-tips",children:"Performance Tips"}),"\n",(0,r.jsxs)(s.ol,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Use appropriate data types"}),": Choose the most specific type for your data"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Leverage lazy evaluation"}),": Chain operations for better optimization"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Minimize data copying"}),": Use references where possible"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Process in chunks"}),": For very large datasets, process in smaller chunks"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Use parallel operations"}),": Enable parallel processing for CPU-intensive tasks"]}),"\n"]}),"\n",(0,r.jsx)(s.h2,{id:"error-handling",children:"Error Handling"}),"\n",(0,r.jsxs)(s.p,{children:["All operations that can fail return ",(0,r.jsx)(s.code,{children:"Result<T, VeloxxError>"}),". Always handle errors appropriately:"]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-rust",children:'match df.filter(&condition) {\n    Ok(filtered_df) => {\n        // Process the filtered DataFrame\n        println!("Filtered to {} rows", filtered_df.row_count());\n    }\n    Err(VeloxxError::ColumnNotFound(col)) => {\n        eprintln!("Column \'{}\' not found", col);\n    }\n    Err(e) => {\n        eprintln!("Error: {}", e);\n    }\n}\n'})})]})}function x(e={}){const{wrapper:s}={...(0,i.R)(),...e.components};return s?(0,r.jsx)(s,{...e,children:(0,r.jsx)(o,{...e})}):o(e)}},8453:(e,s,n)=>{n.d(s,{R:()=>l,x:()=>t});var a=n(6540);const r={},i=a.createContext(r);function l(e){const s=a.useContext(i);return a.useMemo(function(){return"function"==typeof e?e(s):{...s,...e}},[s,e])}function t(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:l(e.components),a.createElement(i.Provider,{value:s},e.children)}}}]);